概要
マイクロサービスアーキテクチャは、クラウドベースやオンプレミスのインフラストラクチャ、高規模なアプリケーションやサービスの設計および実装にますます利用されています。アプリケーションの設計および実装段階で多くのセキュリティ課題があります。設計段階で対処する必要がある基本的なセキュリティ要件は、認証と認可です。したがって、マイクロサービスベースのシステムで認証および認可を実装するために、アプリケーションのセキュリティアーキテクトが既存のアーキテクチャパターンを理解し、適切に使用することが重要です。このチートシートの目的は、そのようなパターンを特定し、アプリケーションのセキュリティアーキテクトに、それを使用する可能な方法に関する推奨事項を提供することです。

エッジレベルの認可
単純なシナリオでは、認可はエッジレベル（APIゲートウェイ）でのみ行われる場合があります。APIゲートウェイは、全てのダウンストリームのマイクロサービスに対する認可の集中的な実施に利用でき、個々のサービスごとに認証とアクセス制御を提供する必要がなくなります。このような場合、NISTは、内部サービスへの直接的な匿名接続（APIゲートウェイバイパス）を防ぐために相互認証などの緩和コントロールを実装することを推奨しています。エッジレイヤーでの認可には以下の制限があることに注意する必要があります：

複数の役割やアクセス制御ルールを持つ複雑なエコシステムで、すべての認可の決定をAPIゲートウェイに押し付けることは管理が難しくなる可能性があります。
APIゲートウェイは、通常「深さの防御」の原則に違反する単一の意思決定ポイントとなり得ます。
通常、運用チームがAPIゲートウェイを所有しているため、開発チームは直接的に認可の変更を行うことができず、追加のコミュニケーションとプロセスのオーバーヘッドにより速度が低下する可能性があります。
ほとんどの場合、開発チームは両方の場所 - エッジレベルで粗い粒度で、およびサービスレベルで認可を実装します。外部エンティティを認証するために、エッジはHTTPヘッダー経由でアクセストークン（参照トークンまたは自己完結型トークン）を使用するか、mTLSを使用することができます。

サービスレベルの認可
サービスレベルの認可は、各マイクロサービスにアクセス制御ポリシーを強制するためのより多くの制御を提供します。さらなる議論のために、NIST SP 800-162に準拠した用語と定義を使用します。アクセス制御システムの機能コンポーネントは、次のように分類できます。

ポリシー管理ポイント（PAP）：アクセス制御ルールの作成、管理、テスト、デバッグを提供するユーザーインターフェースを提供します。
ポリシー決定ポイント（PDP）：適用可能なアクセス制御ポリシーを評価してアクセス決定を計算します。
ポリシー執行ポイント（PEP）：保護されたオブジェクトへのアクセスをリクエストする主体からのリクエストに応じてポリシー決定を強制します。
ポリシー情報ポイント（PIP）：ポリシーの評価に必要な属性またはデータの取得元として機能し、PDPが決定を行うために必要な情報を提供します。

NIST ABACフレームワーク

サービスレベルの認可：既存のパターン
分散パターン
開発チームは、PDPとPEPを直接マイクロサービスのコードレベルで実装します。実装する必要があるすべてのアクセス制御ルールとそのルールを実装するために必要な属性は、各マイクロサービスで定義および保存されます（ステップ1）。マイクロサービスがリクエストを受信すると、認可メタデータ（エンドユーザーコンテキストやリクエストされたリソースIDなど）と共にリクエストを分析し（ステップ3）、アクセス制御ポリシーの決定を生成し、その後認可を強制します（ステップ4）。分散パターンHLD

既存のプログラミング言語フレームワークにより、開発チームはマイクロサービスレベルで認可を実装できます。例えば、Spring Securityは、リソースサーバーでスコープのチェックを有効にすることができ、それを使用して認可を強制することができます（例：着信JWTから抽出されたスコープを使用）。

ソースコードレベルで認可を実装することは、開発チームが認可ロジックを変更したい場合にコードを更新する必要があることを意味します。

単一のポリシー決定ポイントを持つ中央集権化されたパターン
このパターンでは、アクセス制御ルールが中央で定義、保存、評価されます。アクセス制御ルールはPAPを使用して定義され（ステップ1）、評価するために必要な属性と共に中央のPDPに配信されます（ステップ2）。主体がマイクロサービスエンドポイントを呼び出すと（ステップ3）、マイクロサービスコードはネットワークコールを介して中央のPDPを呼び出し、PDPはクエリ入力をアクセス制御ルールと属性に対して評価してアクセス制御ポリシーの決定を生成します（ステップ4）。 PDPの決定に基づいて、マイクロサービスは認可を強制します（ステップ5）。

中央集権化された埋め込みポリシー決定ポイントを持つパターン
このパターンでは、アクセス制御ルールは中央で定義されますが、マイクロサービスレベルで保存および評価されます。アクセス制御ルールはPAPを使用して定義され（ステップ1）、それらのルールを評価するために必要な属性と共に埋め込みPDPに配信されます（ステップ2）。主体がマイクロサービスエンドポイントを呼び出すと（ステップ3）、マイクロサービスコードはPDPを呼び出し、PDPはクエリ入力をアクセス制御ルールと属性に対して評価してアクセス制御ポリシーの決定を生成します（ステップ4）。 PDPの決定に基づいて、マイクロサービスは認可を強制します（ステップ5）。

この場合のPDPコードは、マイクロサービスに組み込まれたライブラリまたはサイドカーとして実装することができます。可能なネットワーク/ホストの障害やネットワークの遅延により、埋め込みPDPをマイクロサービスライブラリまたはサイドカーとして同じホスト（仮想または物理マシン）に展開することが推奨されます。埋め込みPDPは通常、外部依存関係を最小限に抑えるためにメモリ内に認可ポリシーとポリシー関連データを保存し、認可強制中に外部依存関係を最小限に抑えるためにメモリ内に保存します。 "中央集権化された単一のポリシー決定ポイント"アプローチとの主な違いは、認可の決定がマイクロサービス側に保存されないことであり、最新の認可ポリシーが代わりにマイクロサービス側に保存されることです。認可の決定をキャッシュすることが、古い認可ルールの適用およびアクセス制御の違反を引き起こす可能性があることに注意する必要があります。

Netflixは、マイクロサービスレベルで認可を実装するために「埋め込みPDPを持つ中央集権化されたパターン」を使用する実際のケースを紹介しました。

ポリシーポータルおよびポリシーリポジトリは、アクセス制御ルールの作成、管理、およびバージョン管理のためのUIベースのシステムです。
アグリゲータは、すべての外部ソースからアクセス制御ルールに使用されるデータを取得し、それを最新の状態に保ちます。
ディストリビュータは、アクセス制御ルール（ポリシーリポジトリから）およびアクセス制御ルールに使用されるデータ（アグリゲータから）を取得し、それらをPDPの間で配布します。
PDP（ライブラリ）は、非同期にアクセス制御ルールとデータを取得し、PEPコンポーネントによる認可を強制するためにそれらを最新の状態に保ちます。
認可の実装方法に関する推奨事項
拡張性を実現するために、ソースコードに認可ポリシーをハードコードすることは推奨されません（分散パターン）。代わりに、ポリシーを表現するための特別な言語を使用します。目標は、認可をコードから外部化/切り離し、単なるゲートウェイ/プロキシがチェックポイントとして機能するだけでなく、サービスレベルの認可に対する推奨パターンは「埋め込みPDPを持つ中央集権化されたパターン」です。これは、その耐障害性と広範な採用のために推奨されます。
認可ソリューションはプラットフォームレベルのソリューションである必要があります。専用チーム（例：プラットフォームセキュリティチーム）が認可ソリューションの開発および運用、および認可を実装するマイクロサービスブループリント/ライブラリ/コンポーネントの共有に責任を持つ必要があります。
認可ソリューションは広く使用されているソリューションに基づいている必要があります。カスタムソリューションを実装することには次のようなデメリットがあります：
セキュリティまたはエンジニアリングチームがカスタムソリューションを構築および維持する必要があります。
システムアーキテクチャで使用されているすべての言語のためにクライアントライブラリSDKを構築および維持する必要があります。
カスタム認可サービスAPIとその統合についてすべての開発者にトレーニングする必要があります。また、情報を入手するためのオープンソースコミュニティが存在しません。
ゲートウェイ/プロキシと共有認可ライブラリ/コンポーネントですべてのアクセス制御ポリシーが強制される可能性があるが、特定のアクセス制御ルールはマイクロサービスのビジネスコードレベルでまだ実装される必要があります。これを行うために、マイクロサービス開発チームが簡単なアンケート/チェックリストを使用してそのようなセキュリティ要件を明らかにし、マイクロサービス開発中に適切に処理することが推奨されます。
「深さの防御」原則を実装し、次の場所で認可を強制します。
ゲートウェイおよびプロキシレベルでは、粗い粒度で。
共有認可ライブラリ/コンポーネントを使用してマイクロサービスレベルで、詳細な決定を強制します。
ビジネス固有のアクセス制御ルールを実装するために、マイクロサービスビジネスコードレベルで。
アクセス制御ポリシーの形式手順は、開発、承認、および展開で実装する必要があります。
外部エンティティIDの伝播
マイクロサービスレベルで細かい粒度の認可決定を行うためには、マイクロサービスが呼び出し元のコンテキスト（例：ユーザーID、ユーザーロール/グループ）を理解する必要があります。内部サービス間のユーザーIDの伝播を行う方法として、アクセス制御ポリシーで許可されるエンティティID（ユーザーID、リソースID、またはその他のID）を含む必要があります。これは、トランザクションIDを介したコンテキストパラメータの伝播として実装できます。

まとめ
マイクロサービスアーキテクチャは、複雑なアプリケーションを構築するための優れた方法ですが、セキュリティ上の課題も多くあります。特に認証と認可は重要な考慮事項です。このチートシートでは、マイクロサービスアーキテクチャでの認可の実装に関する基本的なパターンと推奨事項について説明しました。これらのパターンとベストプラクティスを適用することで、セキュリティを強化し、アプリケーション全体の安全性を確保できます。