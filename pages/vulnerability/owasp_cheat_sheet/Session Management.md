概要
Web認証、セッション管理、およびアクセス制御：

ウェブセッションは、同じユーザーに関連付けられた一連のネットワークHTTPリクエストとレスポンスのトランザクションです。現代の複雑なウェブアプリケーションでは、複数のリクエストの間、各ユーザーの情報や状態を保持する必要があります。したがって、セッションは、各ユーザーがセッションの期間中にウェブアプリケーションとのすべてのやり取りに適用されるアクセス権やローカライゼーション設定などの変数を確立する能力を提供します。

ウェブアプリケーションは、最初のユーザーリクエストの後に匿名ユーザーを追跡するためのセッションを作成できます。例えば、ユーザーの言語設定を維持することです。また、ユーザーが認証された後にもウェブアプリケーションはセッションを使用します。これにより、ユーザーを任意の後続のリクエストで識別し、セキュリティアクセス制御を適用し、ユーザーのプライベートデータへの認証されたアクセスを可能にし、アプリケーションの使いやすさを向上させることができます。したがって、現在のウェブアプリケーションは、認証前と認証後の両方でセッション機能を提供できます。

認証されたセッションが確立されると、セッションID（またはトークン）は、アプリケーションで使用される最強の認証方法（ユーザー名とパスワード、パスフレーズ、ワンタイムパスワード（OTP）、クライアントベースのデジタル証明書、スマートカード、バイオメトリクス（指紋や眼網膜など）に一時的に相当します。OWASPの認証チートシートを参照してください。

HTTPは状態を持たないプロトコルです（RFC2616セクション5）。つまり、各リクエストとレスポンスの組み合わせは他のウェブの相互作用とは独立しています。したがって、セッションの概念を導入するには、ウェブアプリケーションで一般的に利用可能な認証とアクセス制御（または認可）モジュールの両方をリンクするセッション管理機能を実装する必要があります。

セッションIDまたはトークンは、ユーザー認証資格情報（ユーザーセッションの形式で）をユーザーのHTTPトラフィックとウェブアプリケーションによって強制される適切なアクセス制御に結びつけます。現代のウェブアプリケーションにおけるこれら3つのコンポーネント（認証、セッション管理、アクセス制御）の複雑さと、その実装とバインディングがウェブ開発者の手に委ねられていること（ウェブ開発フレームワークはこれらのモジュール間の厳密な関係を提供しないため）、安全なセッション管理モジュールの実装は非常に困難です。

セッションIDの漏洩、キャプチャ、予測、総当たり攻撃、または固定化は、セッションハイジャック（またはサイドジャック）攻撃につながります。ここで、攻撃者はウェブアプリケーション内の被害者ユーザーを完全になりすますことができます。攻撃者は、ターゲットされた攻撃または一般的な攻撃の2種類のセッションハイジャック攻撃を実行できます。ターゲットされた攻撃では、攻撃者の目標は特定の（または特権のある）ウェブアプリケーションの被害者ユーザーをなりすますことです。一般的な攻撃では、攻撃者の目標は、ウェブアプリケーション内の任意の有効または合法的なユーザーとしてなりすますこと（またはアクセスすること）です。

セッションIDプロパティ

セッションID名の指紋付け
セッションIDで使用される名前は、非常に記述的でないようにし、IDの目的や意味に関する不必要な詳細を提供しないようにする必要があります。

最も一般的なウェブアプリケーション開発フレームワークで使用されるセッションID名は簡単に指紋付けされる可能性があります。例えば、PHPSESSID（PHP）、JSESSIONID（J2EE）、CFID＆CFTOKEN（ColdFusion）、ASP.NET_SessionId（ASP .NET）などです。したがって、セッションID名は、ウェブアプリケーションで使用される技術やプログラミング言語を開示する可能性があります。

ウェブ開発フレームワークのデフォルトのセッションID名をidなどの一般的な名前に変更することが推奨されます。

セッションIDの長さ
セッションIDは、総当たり攻撃を防止するために十分に長くする必要があります。攻撃者がID値の全範囲を試行し、有効なセッションの存在を確認できる攻撃です。

セッションIDの長さは少なくとも128ビット（16バイト）でなければなりません。

注：セッションIDの長さは、次のセッションIDエントロピーで行われた仮定に基づいて参考値として提供されています。ただし、この数値は絶対的な最小値として考えるべきではなく、他の実装要因がその強度に影響する可能性があります。
例えば、マイクロソフトASP.NETセッションIDなど、よく知られた実装があります。"ASP .NETセッション識別子は、小文字のaからzまでの文字と0から5の数字で構成される24文字の文字列にエンコードされたランダムに生成された番号です"。
非常に効果的なエントロピーを提供し、結果として、推測または総当たり攻撃を回避するのに十分な長さであると見なすことができます。

セッションIDエントロピー
セッションIDは、予測不可能（十分にランダム）である必要があります。攻撃者が統計分析技術を使用して有効なセッションのIDを推測または予測できる攻撃を防ぐために、良好なCSPRNG（Cryptographically Secure Pseudorandom Number Generator）を使用する必要があります。

セッションIDの値は、少なくとも64ビットのエントロピーを提供する必要があります（良好なPRNGが使用されている場合、この値はセッションIDの長さの半分と推定されます）。

さらに、ランダムなセッションIDだけでは不十分です。重複したIDを避けるためにも一意でなければなりません。ランダムなセッションIDは、現在のセッションIDスペースに既に存在していてはなりません。

注：セッションIDのエントロピーは、他の外部的で測定が難しい要因（ウェブアプリケーションが通常持つ同時アクティブセッション数、絶対セッション有効期限のタイムアウト、攻撃者が行うことができる秒ごとのセッションID推測の量、対象のウェブアプリケーションがサポートできるなど）によって実際に影響を受けます。セッションIDの推測を成功させるためには、攻撃者が秒間1万回の推測を試み、ウェブアプリケーションで利用可能な100,000個の有効な同時セッションがあると仮定した場合、攻撃者が292年以上を費やすことができると見込まれます。
詳細はこちら。

セッションIDのコンテンツ（または値）
セッションIDのコンテンツ（または値）は、情報漏洩攻撃を防ぐために無意味でなければなりません。攻撃者がIDの内容をデコードし、ユーザー、セッション、またはウェブアプリケーションの内部動作の詳細を抽出できる攻撃です。

セッションIDは単にクライアント側での識別子であり、その値には機密情報や個人を特定できる情報（PII）を含めてはいけません。PIIについては、Wikipediaやこの記事を参照してください。

セッションIDに関連する意味、ビジネス、またはアプリケーションロジックは、サーバー側に格納する必要があります。具体的には、セッションオブジェクトやセッション管理データベース、またはリポジトリに格納します。

格納される情報には、クライアントのIPアドレス、User-Agent、電子メール、ユーザー名、ユーザーID、役割、特権レベル、アクセス権、言語設定、アカウントID、現在の状態、最終ログイン、セッションタイムアウト、その他の内部セッションの詳細が含まれます。セッションオブジェクトとプロパティに機密情報が含まれる場合は、適切に暗号化し、セッション管理リポジトリを保護する必要があります。

言語やフレームワークが生成するセッションIDを使用することをお勧めします。独自のセッションIDを作成する必要がある場合は、少なくとも128ビットのサイズで暗号的に安全な疑似ランダム数生成器（CSPRNG）を使用し、各セッションIDが一意であることを確認してください。

セッション管理の実装
セッション管理の実装は、ユーザーとウェブアプリケーションの間でセッションIDを共有し、連続して交換するために使用される交換メカニズムを定義します。ウェブアプリケーション内でセッションの状態を維持するために利用可能なHTTP内の複数のメカニズムがあります。例えば、クッキー（標準HTTPヘッダー）、URLパラメータ（URLリライト – RFC2396）、GETリクエストのURL引数、POSTリクエストのボディ引数（HTMLフォームの隠しフィールド）、またはプロプライエタリなHTTPヘッダーです。

推奨されるセッションID交換メカニズムは、トークンの有効期限日時や粒度の制約など、高度なトークンプロパティの定義を許可する必要があります。これは、クッキー（RFC 2109＆2965＆6265）が他の方法では利用できない高度な機能を提供するため、最も広く使用されているセッションID交換メカニズムの1つである理由の1つです。

セッションIDを含む特定の交換メカニズムの使用は、セッションIDを公開する（ウェブリンクとログ、ウェブブラウザの履歴やブックマーク、リファラヘッダーや検索エンジン）、また、IDまたはセッション固定攻撃の操作を容易にすることがあります。

組み込みセッション管理実装
J2EE、ASP .NET、PHPなどのウェブ開発フレームワークは、それぞれ独自のセッション管理機能と関連する実装を提供しています。これらの組み込みフレームワークをゼロから構築する代わりに使用することが推奨されます。なぜなら、これらは世界中の複数のウェブ環境で使用されており、ウェブアプリケーションセキュリティおよび開発コミュニティによって時間をかけてテストされているからです。

ただし、これらのフレームワークには過去に脆弱性や弱点が見つかっていますので、常に利用可能な最新バージョンを使用し、このドキュメントで説明されている推奨事項に従ってデフォルト構成を確認および変更することが推奨されます。

セッション管理メカニズムが一時的にセッションIDを保存するストレージ機能またはリポジトリは、ローカルまたはリモートの偶発的な情報漏洩や不正アクセスからセッションIDを保護する必要があります。

使用されているセッションID交換メカニズムと受け入れられているセッションID交換メカニズム
ウェブアプリケーションは、セッションID交換管理にクッキーを使用する必要があります。ユーザーが異なる交換メカニズム（URLパラメータなど）を介してセッションIDを送信した場合、セッション固定を停止するための防御的戦略の一環として、ウェブアプリケーションはそれを受け入れないようにする必要があります。

注：ウェブアプリケーションがデフォルトのセッションID交換メカニズムとしてクッキーを使用する場合でも、他の交換メカニズムを受け入れる場合があります。
この場合、クッキーベースのセッションID交換メカニズムとその他の交換メカニズムを同時に有効にすると、ウェブアプリケーションのセッション固定防御が不十分になります。攻撃者は、最も弱いセッションID交換メカニズムを探して試すことができます。したがって、ウェブアプリケーションは、セッションID交換メカニズムとしてクッキーのみを使用するように構成する必要があります。

クッキーを使用してセッションIDを交換する場合、ウェブアプリケーションはクッキー属性の安全な設定（Secure、HttpOnly、SameSite）を適用する必要があります。これは、クッキーベースのセッションID交換メカニズムのセキュリティを向上させ、クロスサイトスクリプティング（XSS）、セッション固定、および他のリスクから保護します。

注：XSSとセッション固定のリスクに対する防御的戦略は、クッキーを介してセッションIDを交換するすべてのセッション管理メカニズムに適用されるべきです。これは、クッキーがセッションIDを送信するために使用されている場合でも同様です（クッキーベースのセッションID交換メカニズムの場合）。

クッキーの安全な属性設定
セキュリティを向上させるために、セッション管理フレームワークは、クッキーの安全な属性設定を利用する必要があります。これらの属性にはSecure、HttpOnly、およびSameSiteが含まれます。

セッションIDを含むセッションクッキーにSecure属性を適用することで、クッキーはHTTPS（SSL / TLS）でのみ送信されます。これにより、攻撃者がクッキーを傍受してセッションIDを取得するリスクが低減します。

HttpOnly属性を使用すると、ブラウザのJavaScriptエンジンがクッキーにアクセスできなくなります。これにより、クロスサイトスクリプティング（XSS）攻撃が成功しても、攻撃者はセッションIDを直接取得することができなくなります。

SameSite属性を使用すると、ブラウザはサイト外のコンテキストでのリクエストでのみクッキーを送信します。これにより、クロスサイトリクエストフォージェリ（CSRF）攻撃から保護されます。

これらのセッションクッキーの安全な属性を利用することにより、セッションIDが漏洩または悪用されるリスクが低減し、ウェブアプリケーションのセキュリティが向上します。
HTML5 Web Storage API¶
HTML5のWebストレージAPIは、Webハイパーテキストアプリケーションテクノロジーグループ（WHATWG）によって、クライアント側で名前と値のペアを保存するための仕組みとして説明されています。localStorageとsessionStorageとして知られるこれらのAPIは、HTTPクッキーとは異なり、ブラウザによってリクエストやレスポンス内で自動的に共有されず、データをクライアント側で保存するために使用されます。

localStorage API¶
スコープ¶
localStorage APIを使用して保存されたデータは、同じオリジンから読み込まれたページからアクセス可能です。オリジンは、スキーム（https://）、ホスト（example.com）、ポート（443）、ドメイン/レルム（example.com）で定義されます。これにより、httpsから保存されたデータをhttp経由で取得することはできません。異なるウィンドウ/スレッドからの同時アクセスが可能なため、localStorageを使用して保存されたデータは共有アクセスの問題（競合状態など）に対して脆弱であり、ロックされないことが考慮されます（WebストレージAPI仕様）。

期間¶
localStorage APIを使用して保存されたデータは、ブラウジングセッションを超えて永続化され、他のシステムユーザーがアクセスできる時間枠が延長されます。

オフラインアクセス¶
規格ではlocalStorageデータを暗号化して保存することは求められず、これによりデータを直接ディスクからアクセスすることが可能です。

ユースケース¶
WHATWGは、ウィンドウやタブ間でアクセスする必要があり、複数のセッションで大量のデータ（複数メガバイト）をパフォーマンス上の理由から保存する必要があるデータにlocalStorageを使用することを提案しています。

sessionStorage API¶
スコープ¶
sessionStorage APIは、呼び出されたウィンドウコンテキスト内でデータを保存し、したがってタブ1はタブ2から保存されたデータにアクセスすることはできません。また、localStorage APIと同様に、sessionStorage APIを使用して保存されたデータは、同じオリジンから読み込まれたページからアクセス可能です。これにより、httpsから保存されたデータをhttp経由で取得することはできません。

期間¶
sessionStorage APIは、現在のブラウジングセッションの期間中のみデータを保存します。タブが閉じられると、そのデータはもはや取得できません。これは、ブラウザタブが再利用されたり開いたりした場合にアクセスを防ぐものではありません。データはガベージコレクションイベントまでメモリに残る可能性もあります。

オフラインアクセス¶
規格ではsessionStorageデータを暗号化して保存することは求められず、これによりデータを直接ディスクからアクセスすることが可能です。

ユースケース¶
WHATWGは、1つのワークフローインスタンスに関連するデータ（例：チケット予約の詳細）にsessionStorageを使用することを提案していますが、他のタブで複数のワークフローを同時に実行できるような場合です。ウィンドウ/タブバウンドの性質により、別々のタブ間でワークフローが漏洩するのを防ぎます。